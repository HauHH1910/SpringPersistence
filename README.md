# How to map a bidirectional many-to-many association

## Problem:
    My table models contains a many-to-many association.
    How do I model it with Hibernate so that I can navigate in both directions?
## Solution:
You need to model the association on both entities if you want to be able to navigate it in both directions.

Let’s have a look at an example: 

    Multiple Authors can write multiple books and a book can be written by one or more authors.
    That’s a typical many-to-many association, and you probably want to navigate it in both directions in your domain model and queries. 
    You need to model it as a many-to-many association on the Book entity and the Author entity.\

![img.png](img.png)

    Let’s begin with the Book entity, which is the owning side of the association in this example. 

    That means that it defines the association and the Author entity just references it

    The relationship definition consists of two mandatory and one optional part. 
    The entity attribute List<Author> authors and the @ManyToMany annotation are required.
    The attribute models the association, and the annotation declares the kind of relationship. 
        The @JoinTable annotation is optional. 
        It allows you to define the name of the join table and foreign key columns that store the many-to-many association. 
    I use it in the following code snippet to set the name of the join table to book_author and the names of the foreign key columns to fk_book and fk_author

    If you don’t define the name yourself, Hibernate generates default table and column names.
    The default table name is the combination of both entity names.
    In this example, it would be Book_Author. 
        The foreign key column name is generated by combining the name of the association mapping attribute and the name of the primary key attribute of the entity.
        These would be books_id and authors_id in this example.

```java
import jakarta.persistence.*;

import java.util.ArrayList;
import java.util.List;

@Entity
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id", updatable = false, nullable = false)
    private Long id;
    
    @ManyToMany
    @JoinTable(
            name = "book_author",
            joinColumns = @JoinColumn(name = "fk_book"),
            inverseJoinColumns = @JoinColumn(name = "fk_author")
    )
    private List<Author> authors = new ArrayList<>();
}

@Entity
public class Author {
    
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id", updatable = false, nullable = false)
    private Long id;
    
    @ManyToMany(mappedBy = "authors")
    private List<Book> books = new ArrayList<>();
}
```

You also need to map the many-to-many association on the Author entity to make it bidirectional.
As you can see in the following code snippet, this is done in a similar way as on the Book entity. 
You need an attribute that models the association and a @ManyToMany annotation. 
In this example, it’s the List<Book> books attribute that I annotated with a @ManyToMany annotation.
The association is already defined on the Book entity. 
You can therefore just reference the attribute on the Book entity in the mappedBy attribute and Hibernate uses the same definition


Bidirectional associations are easy to use in queries, but they also require an additional step when you persist new entity.
You need to **update** the association on both sides when you add or remove an entity


```java

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;

import java.util.ArrayList;
import java.util.List;

@Getter
@Setter
@Entity
public class Book {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id", updatable = false, nullable = false)
    private Long id;
    
    @ManyToMany
    @JoinTable(
            name = "book_author",
            joinColumns = @JoinColumn(name = "fk_book"),
            inverseJoinColumns = @JoinColumn(name = "fk_author")
    )
    private List<Author> authors = new ArrayList<>();

    //Other attribute
}

@Getter
@Setter
@Entity
public class Author {
    
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id", updatable = false, nullable = false)
    private Long id;
    
    @ManyToMany(mappedBy = "authors")
    private List<Book> books = new ArrayList<>();
    
    //Other attribute
    
    public void addBook(Book newBook){
        this.books.add(newBook);
        newBook.getAuthors().add(this);
    }
    
    public void removeBook(Book removeBook){
        this.books.remove(removeBook);
        removeBook.getAuthors().remove(this);
    }
}
```












